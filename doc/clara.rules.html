<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clara.rules documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clara-rules 0.4.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="clara.rules.html"><span>clara.rules</span></a></li><li><a href="clara.rules.accumulators.html"><span>clara.rules.accumulators</span></a></li><li><a href="clara.rules.dsl.html"><span>clara.rules.dsl</span></a></li><li><a href="clara.rules.schema.html"><span>clara.rules.schema</span></a></li><li><a href="clara.tools.viz.html"><span>clara.tools.viz</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="clara.rules.html#var-accumulate"><span>accumulate</span></a></li><li><a href="clara.rules.html#var-add-productions"><span>add-productions</span></a></li><li><a href="clara.rules.html#var-defquery"><span>defquery</span></a></li><li><a href="clara.rules.html#var-defrule"><span>defrule</span></a></li><li><a href="clara.rules.html#var-defsession"><span>defsession</span></a></li><li><a href="clara.rules.html#var-fire-rules"><span>fire-rules</span></a></li><li><a href="clara.rules.html#var-insert"><span>insert</span></a></li><li><a href="clara.rules.html#var-insert%21"><span>insert!</span></a></li><li><a href="clara.rules.html#var-insert-all"><span>insert-all</span></a></li><li><a href="clara.rules.html#var-insert-unconditional%21"><span>insert-unconditional!</span></a></li><li><a href="clara.rules.html#var-mk-query"><span>mk-query</span></a></li><li><a href="clara.rules.html#var-mk-rule"><span>mk-rule</span></a></li><li><a href="clara.rules.html#var-mk-rulebase"><span>mk-rulebase</span></a></li><li><a href="clara.rules.html#var-mk-session"><span>mk-session</span></a></li><li><a href="clara.rules.html#var-query"><span>query</span></a></li><li><a href="clara.rules.html#var-retract"><span>retract</span></a></li><li><a href="clara.rules.html#var-retract%21"><span>retract!</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>clara.rules documentation</h2><pre class="doc">Forward-chaining rules for Clojure. The primary API is in this namespace.
</pre><div class="public" id="var-accumulate"><h3>accumulate</h3><div class="usage"><code>(accumulate &amp; {:keys [initial-value reduce-fn combine-fn retract-fn convert-return-fn], :as args})</code></div><pre class="doc">Creates a new accumulator based on the given properties:

* An initial-value to be used with the reduced operations.
* A reduce-fn that can be used with the Clojure Reducers library to reduce items.
* A combine-fn that can be used with the Clojure Reducers library to combine reduced items.
* An optional retract-fn that can remove a retracted fact from a previously reduced computation
* An optional convert-return-fn that converts the reduced data into something useful to the caller.
  Simply uses identity by default.
 </pre></div><div class="public" id="var-add-productions"><h3>add-productions</h3><div class="usage"><code>(add-productions rulebase &amp; productions)</code></div><pre class="doc">DEPRECATED as of 0.4. Simply conjoin productions and create a new session.

Returns a new rulebase identical to the given one, but with the additional
rules or queries. This is only used when dynamically adding rules to a rulebase.</pre></div><div class="public" id="var-defquery"><h3>defquery</h3><h4 class="macro">macro</h4><div class="usage"><code>(defquery name &amp; body)</code></div><pre class="doc">Defines a query and stored it in the given var. For instance, a simple query that accepts no
   parameters would look like this:
    
(defquery check-job
  &quot;Checks the job for validation errors.&quot;
  []
  [?issue &lt;- ValidationError])

   See the guide at https://github.com/rbrush/clara-rules/wiki/Guide for details.</pre></div><div class="public" id="var-defrule"><h3>defrule</h3><h4 class="macro">macro</h4><div class="usage"><code>(defrule name &amp; body)</code></div><pre class="doc">Defines a rule and stores it in the given var. For instance, a simple rule would look like this:

(defrule hvac-approval
  &quot;HVAC repairs need the appropriate paperwork, so insert a validation error if approval is not present.&quot;
  [WorkOrder (= type :hvac)]
  [:not [ApprovalForm (= formname &quot;27B-6&quot;)]]
  =&gt;
  (insert! (-&gt;ValidationError 
            :approval 
            &quot;HVAC repairs must include a 27B-6 form.&quot;)))
  
  See the guide at https://github.com/rbrush/clara-rules/wiki/Guide for details.</pre></div><div class="public" id="var-defsession"><h3>defsession</h3><h4 class="macro">macro</h4><div class="usage"><code>(defsession name &amp; sources-and-options)</code></div><pre class="doc">Creates a sesson given a list of sources and keyword-style options, which are typically Clojure namespaces.

  Typical usage would be like this, with a session defined as a var:

(defsession my-session 'example.namespace)

That var contains an immutable session that then can be used as a starting point to create sessions with
caller-provided data. Since the session itself is immutable, it can be safely used from multiple threads
and will not be modified by callers. So a user might grab it, insert facts, and otherwise
use it as follows:

   (-&gt; my-session
     (insert (-&gt;Temperature 23))
     (fire-rules))  

   </pre></div><div class="public" id="var-fire-rules"><h3>fire-rules</h3><div class="usage"><code>(fire-rules session)</code></div><pre class="doc">Fires are rules in the given session. Once a rule is fired, it is labeled in a fired
state and will not be re-fired unless facts affecting the rule are added or retracted.

This function does not modify the given session to mark rules as fired. Instead, it returns
a new session in which the rules are marked as fired.</pre></div><div class="public" id="var-insert"><h3>insert</h3><div class="usage"><code>(insert session &amp; facts)</code></div><pre class="doc">Inserts one or more facts into a working session. It does not modify the given
session, but returns a new session with the facts added.</pre></div><div class="public" id="var-insert%21"><h3>insert!</h3><div class="usage"><code>(insert! &amp; facts)</code></div><pre class="doc">To be executed within a rule's right-hand side, this inserts a new fact or facts into working memory.

Inserted facts are logical, in that if the support for the insertion is removed, the fact
will automatically be retracted. For instance, if there is a rule that inserts a &quot;Cold&quot; fact
if a &quot;Temperature&quot; fact is below a threshold, and the &quot;Temperature&quot; fact that triggered
the rule is retracted, the &quot;Cold&quot; fact the rule inserted is also retracted. This is the underlying
truth maintenance facillity.

This truth maintenance is also transitive: if a rule depends on some criteria to fire, and a 
criterion becomes invalid, it may retract facts that invalidate other rules, which in turn
retract their conclusions. This way we can ensure that information inferred by rules is always
in a consistent state.</pre></div><div class="public" id="var-insert-all"><h3>insert-all</h3><div class="usage"><code>(insert-all session fact-seq)</code></div><pre class="doc">Inserts a sequence of facts into a working session. It does not modify the given
session, but returns a new session with the facts added.</pre></div><div class="public" id="var-insert-unconditional%21"><h3>insert-unconditional!</h3><div class="usage"><code>(insert-unconditional! &amp; facts)</code></div><pre class="doc">To be executed within a rule's right-hand side, this inserts a new fact or facts into working memory.

This differs from insert! in that it is unconditional. The facts inserted will not be retracted
even if the rule activation doing the insert becomes false.  Most users should prefer the simple insert!
function as described above, but this function is available for use cases that don't wish to use
Clara's truth maintenance.</pre></div><div class="public" id="var-mk-query"><h3>mk-query</h3><h4 class="macro">macro</h4><div class="usage"><code>(mk-query params lhs)</code></div><pre class="doc">DEPRECATED. Users generally should use defquery, although clojure.rules.dsl/parse-query is available for specialized needs.

Creates a new query based on a sequence of a conditions. 
This is only used when creating queries dynamically; most users should use defquery instead.</pre></div><div class="public" id="var-mk-rule"><h3>mk-rule</h3><h4 class="macro">macro</h4><div class="usage"><code>(mk-rule lhs rhs)</code><code>(mk-rule lhs rhs properties)</code></div><pre class="doc">DEPRECATED. Users generally should use defrule, although clojure.rules.dsl/parse-rule is available for specialized needs.

Creates a new rule based on a sequence of a conditions and a righthand side. 
This is only used when creating new rules directly; most users should use defrule instead.</pre></div><div class="public" id="var-mk-rulebase"><h3>mk-rulebase</h3><div class="usage"><code>(mk-rulebase &amp; productions)</code></div><pre class="doc">DEPRECATED as of 0.4. Just use mk-session directly against a sequence of productions. The rulebase
construct is no longer necessary in this API.

Creates a rulebase with the given productions. This is only used when generating rulebases dynamically.</pre></div><div class="public" id="var-mk-session"><h3>mk-session</h3><h4 class="macro">macro</h4><div class="usage"><code>(mk-session &amp; args)</code></div><pre class="doc">Creates a new session using the given rule sources. Thew resulting session
is immutable, and can be used with insert, retract, fire-rules, and query functions.

If no sources are provided, it will attempt to load rules from the caller's namespace.

The caller may also specify keyword-style options at the end of the parameters. Currently two
options are supported:

* :fact-type-fn, which must have a value of a function used to determine the logical type of a given 
  cache. Defaults to Clojures type function.
* :cache, indicating whether the session creation can be cached, effectively memoizing mk-session. 
  Defaults to true. Callers may wish to set this to false when needing to dynamically reload rules.

This is not supported in ClojureScript, since it requires eval to dynamically build a session. ClojureScript
users must use pre-defined rulesessions using defsession.</pre></div><div class="public" id="var-query"><h3>query</h3><div class="usage"><code>(query session query &amp; params)</code></div><pre class="doc">Runs the given query with the optional given parameters against the session.
The optional parameters should be in map form. For example, a query call might be:

(query session get-by-last-name :last-name &quot;Jones&quot;)

The query itself may be either the var created by a defquery statement,
or the actual name of the query.
</pre></div><div class="public" id="var-retract"><h3>retract</h3><div class="usage"><code>(retract session &amp; facts)</code></div><pre class="doc">Retracts a fact from a working session. It does not modify the given session,
but returns a new session with the facts retracted.</pre></div><div class="public" id="var-retract%21"><h3>retract!</h3><div class="usage"><code>(retract! &amp; facts)</code></div><pre class="doc">To be executed within a rule's right-hand side, this retracts a fact or facts from the working memory.

Retracting facts from the right-hand side has slightly different semantics than insertion. As described
in the insert! documentation, inserts are logical and will automatically be retracted if the rule
that inserted them becomes false. This retract! function does not follow the inverse; retracted items
are simply removed, and not re-added if the rule that retracted them becomes false.

The reason for this is that retractions remove information from the knowledge base, and doing truth
maintenance over retractions would require holding onto all retracted items, which would be an issue
in some use cases. This retract! method is included to help with certain use cases, but unless you 
have a specific need, it is better to simply do inserts on the rule's right-hand side, and let
Clara's underlying truth maintenance retract inserted items if their support becomes false.</pre></div></div></body></html>